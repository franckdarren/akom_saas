generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================================
// ENUMS
// ============================================================

enum UserRole {
  admin
  kitchen
  cashier

  @@map("user_role")
}

enum OrderStatus {
  pending
  preparing
  ready
  delivered
  cancelled

  @@map("order_status")
}

enum PaymentStatus {
  pending
  paid
  failed
  refunded

  @@map("payment_status")
}

enum PaymentMethod {
  cash
  mobile_money
  airtel_money // Airtel Money Gabon
  moov_money // Moov Money Gabon
  card

  @@map("payment_method")
}

enum PaymentTiming {
  before_meal
  after_meal

  @@map("payment_timing")
}

enum StockMovementType {
  manual_in
  manual_out
  adjustment
  order_out
  sale_manual // Vente manuelle (depuis le module caisse) — déclenche sortie stock
  purchase // Achat fournisseur (depuis une dépense) — déclenche entrée stock

  @@map("stock_movement_type")
}

enum TicketStatus {
  open
  in_progress
  resolved
  closed

  @@map("ticket_status")
}

enum TicketPriority {
  low
  medium
  high
  urgent

  @@map("ticket_priority")
}

enum LogLevel {
  info
  warning
  error
  critical

  @@map("log_level")
}

enum PermissionResource {
  restaurants
  users
  menu
  categories
  products
  tables
  orders
  stocks
  payments
  stats
  roles

  @@map("permission_resource")
}

enum PermissionAction {
  create
  read
  update
  delete
  manage // Accès complet à la ressource

  @@map("permission_action")
}

enum InvitationStatus {
  pending // En attente d'acceptation
  accepted // Acceptée
  expired // Expirée (après 7 jours)
  revoked // Révoquée par l'admin

  @@map("invitation_status")
}

enum SubscriptionPlan {
  starter
  business
  premium

  @@map("subscription_plan")
}

enum SubscriptionStatus {
  trial // Période d'essai active
  active // Abonnement actif et payé
  expired // Abonnement expiré
  suspended // Suspendu manuellement par admin
  cancelled // Annulé par le client

  @@map("subscription_status")
}

enum SubscriptionPaymentMethod {
  manual // Virement/dépôt manuel (MVP)
  airtel_money
  moov_money
  mobile_money
  card // Carte bancaire (futur)

  @@map("subscription_payment_method")
}

enum SubscriptionPaymentStatus {
  pending // En attente de validation
  confirmed // Confirmé et validé
  failed // Échoué
  refunded // Remboursé

  @@map("subscription_payment_status")
}

enum ProductType {
  good // Bien physique avec gestion de stock
  service // Prestation de service sans stock

  @@map("product_type")
}

enum RestaurantVerificationStatus {
  pending_documents // En attente des documents
  documents_submitted // Documents soumis, en attente validation
  documents_rejected // Documents rejetés par le superadmin
  verified // Vérifié et actif
  suspended // Suspendu (ex: fiche circuit manquante)

  @@map("restaurant_verification_status")
}

enum OrderSource {
  qr_table // Via QR code sur une table physique
  public_link // Via le lien catalogue public
  dashboard // Créée manuellement par le staff
  counter // Prise de commande au comptoir par la caissière

  @@map("order_source")
}

enum FulfillmentType {
  table // Sur place (table connue)
  takeway // À emporter (pick-up)
  delivery // Livraison (post-MVP si besoin)
  reservation // Réservation de table future

  @@map("fulfillment_type")
}

enum CashSessionStatus {
  open
  closed

  @@map("cash_session_status")
}

enum RevenueType {
  good // Bien physique → déclenche une sortie de stock automatique
  service // Prestation de service → aucun impact sur le stock

  @@map("revenue_type")
}

enum ExpenseCategory {
  stock_purchase // Achat marchandises → fait entrer des produits en stock
  salary // Salaires et charges sociales
  utilities // Eau, électricité, internet, téléphone
  transport // Livraisons, déplacements, carburant
  maintenance // Réparations, entretien du matériel
  marketing // Publicité, impression menus, réseaux sociaux
  rent // Loyer et charges locatives
  other // Divers non catégorisé

  @@map("expense_category")
}

// ============================================================
// MODELS
// ============================================================

model Restaurant {
  id            String   @id @default(uuid()) @db.Uuid
  name          String
  slug          String   @unique
  phone         String?
  address       String?
  logoUrl       String?  @map("logo_url")
  coverImageUrl String?  @map("cover_image_url")
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  ebillingUsername   String? @map("ebilling_username")
  ebillingSharedKey  String? @map("ebilling_shared_key")
  ebillingConfigured Boolean @default(false) @map("ebilling_configured")

  // ✅ Vérification
  verificationStatus RestaurantVerificationStatus @default(pending_documents) @map("verification_status")
  isVerified         Boolean                      @default(false) @map("is_verified")

  // Relations
  users                   RestaurantUser[]
  tables                  Table[]
  categories              Category[]
  families                Family[]
  products                Product[]
  stocks                  Stock[]
  orders                  Order[]
  payments                Payment[]
  stockMovements          StockMovement[]
  dailyStats              DailyStats[]
  supportTickets          SupportTicket[]
  roles                   Role[]
  invitations             Invitation[]
  subscription            Subscription?
  subscriptionPayments    SubscriptionPayment[]
  subscriptionEmailLogs   SubscriptionEmailLog[]
  verificationDocuments   RestaurantVerificationDocument?
  circuitSheet            RestaurantCircuitSheet?
  verificationHistory     RestaurantVerificationHistory[]
  // Nouvelles relations pour le module entrepôt
  warehouseProducts       WarehouseProduct[]
  warehouseStocks         WarehouseStock[]
  warehouseMovements      WarehouseMovement[]
  warehouseToOpsTransfers WarehouseToOpsTransfer[]
  cashSessions            CashSession[]
  manualRevenues          ManualRevenue[]
  expenses                Expense[]

  @@index([slug])
  @@index([isActive])
  @@index([verificationStatus])
  @@map("restaurants")
}

model RestaurantUser {
  id           String    @id @default(uuid()) @db.Uuid
  userId       String    @map("user_id") @db.Uuid
  restaurantId String    @map("restaurant_id") @db.Uuid
  role         UserRole?
  createdAt    DateTime  @default(now()) @map("created_at")
  roleId       String?   @map("role_id") @db.Uuid

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  customRole Role?      @relation(fields: [roleId], references: [id], onDelete: SetNull)

  @@unique([userId, restaurantId])
  @@index([userId])
  @@map("restaurant_users")
}

model Table {
  id           String   @id @default(uuid()) @db.Uuid
  restaurantId String   @map("restaurant_id") @db.Uuid
  number       Int
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  orders     Order[]

  @@unique([restaurantId, number])
  @@index([restaurantId, isActive])
  @@map("tables")
}

model Category {
  id           String   @id @default(uuid()) @db.Uuid
  restaurantId String   @map("restaurant_id") @db.Uuid
  name         String
  description  String?
  position     Int      @default(0)
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  products   Product[]
  families   Family[]

  @@map("categories")
}

model Family {
  id           String   @id @default(uuid()) @db.Uuid
  restaurantId String   @map("restaurant_id") @db.Uuid
  categoryId   String   @map("category_id") @db.Uuid
  name         String
  description  String?
  position     Int      @default(0)
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  products   Product[]

  // Index pour la performance et l'unicité
  @@unique([restaurantId, categoryId, name])
  @@index([restaurantId])
  @@index([categoryId])
  @@index([restaurantId, categoryId, position])
  @@map("families")
}

model Product {
  id           String  @id @default(uuid()) @db.Uuid
  restaurantId String  @map("restaurant_id") @db.Uuid
  categoryId   String? @map("category_id") @db.Uuid
  familyId     String? @map("family_id") @db.Uuid

  // Informations de base
  name        String
  description String?

  // Type et tarification
  productType  ProductType @default(good) @map("product_type")
  price        Int? // Prix en FCFA - NULL si "sur devis"
  includePrice Boolean     @default(true) @map("include_price")

  // Gestion de stock
  hasStock Boolean @default(true) @map("has_stock")

  // Média et disponibilité
  imageUrl    String? @map("image_url")
  isAvailable Boolean @default(true) @map("is_available")

  // Métadonnées
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant             Restaurant               @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  category               Category?                @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  family                 Family?                  @relation(fields: [familyId], references: [id], onDelete: SetNull)
  stock                  Stock?
  orderItems             OrderItem[]
  stockMovements         StockMovement[]
  // Nouvelles relations pour le module entrepôt
  linkedFromWarehouse    WarehouseProduct[]       @relation("WarehouseToProduct")
  transfersFromWarehouse WarehouseToOpsTransfer[] @relation("TransferToProduct")
  manualRevenues         ManualRevenue[]
  expenses               Expense[]

  @@index([restaurantId, categoryId])
  @@index([restaurantId, isAvailable])
  @@index([restaurantId, productType])
  @@index([restaurantId, hasStock])
  @@map("products")
}

model Stock {
  id             String   @id @default(uuid()) @db.Uuid
  restaurantId   String   @map("restaurant_id") @db.Uuid
  productId      String   @unique @map("product_id") @db.Uuid
  quantity       Int      @default(0)
  alertThreshold Int      @default(5) @map("alert_threshold")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  product    Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([restaurantId, productId])
  @@index([productId])
  @@map("stocks")
}

model Order {
  id           String      @id @default(uuid()) @db.Uuid
  restaurantId String      @map("restaurant_id") @db.Uuid
  tableId      String?     @map("table_id") @db.Uuid
  orderNumber  String?     @map("order_number")
  customerName String?     @map("customer_name")
  status       OrderStatus @default(pending)
  totalAmount  Int         @default(0) @map("total_amount") // Montant en FCFA (entier)
  notes        String?
  tableLabel   String?     @map("table_label") // ← NOUVEAU : ex: "Comptoir", "Terrasse"
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")

  isArchived Boolean @default(false)

  source          OrderSource      @default(qr_table)
  fulfillmentType FulfillmentType?
  stockDeducted   Boolean          @default(false) @map("stock_deducted")

  // Pour les commandes PUBLIC_LINK sans table connue
  customerPhone String?   @map("customer_phone")
  customerEmail String?   @map("customer_email")
  pickupTime    DateTime? @map("pickup_time") // Pour TAKEAWAY

  // Pour les réservations
  reservationDate DateTime? @map("reservation_date")
  partySize       Int?      @map("party_size")

  // Relations
  restaurant     Restaurant      @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  table          Table?          @relation(fields: [tableId], references: [id], onDelete: SetNull)
  orderItems     OrderItem[]
  payments       Payment[]
  stockMovements StockMovement[]

  @@unique([restaurantId, orderNumber])
  @@index([restaurantId, status])
  @@index([restaurantId, createdAt(sort: Desc)])
  @@index([isArchived, status])
  @@map("orders")
}

model OrderItem {
  id          String @id @default(uuid()) @db.Uuid
  orderId     String @map("order_id") @db.Uuid
  productId   String @map("product_id") @db.Uuid
  productName String @map("product_name")
  quantity    Int
  unitPrice   Int    @map("unit_price") // Prix unitaire en FCFA au moment de la commande

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])

  @@index([orderId])
  @@map("order_items")
}

model Payment {
  id            String        @id @default(uuid()) @db.Uuid
  restaurantId  String        @map("restaurant_id") @db.Uuid
  orderId       String        @map("order_id") @db.Uuid
  amount        Int // Montant en FCFA (entier)
  method        PaymentMethod
  status        PaymentStatus @default(pending)
  timing        PaymentTiming
  transactionId String?       @map("transaction_id")
  phoneNumber   String?       @map("phone_number")
  errorMessage  String?       @map("error_message")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  order      Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@map("payments")
}

model StockMovement {
  id           String            @id @default(uuid()) @db.Uuid
  restaurantId String            @map("restaurant_id") @db.Uuid
  productId    String            @map("product_id") @db.Uuid
  userId       String            @map("user_id") @db.Uuid
  type         StockMovementType
  quantity     Int
  previousQty  Int               @map("previous_qty")
  newQty       Int               @map("new_qty")
  reason       String?
  orderId      String?           @map("order_id") @db.Uuid
  createdAt    DateTime          @default(now()) @map("created_at")

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  product    Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  order      Order?     @relation(fields: [orderId], references: [id], onDelete: SetNull)

  manualRevenue ManualRevenue? @relation("ManualRevenueStockMovement")
  expense       Expense?       @relation("ExpenseStockMovement")

  @@index([restaurantId, productId])
  @@index([restaurantId, createdAt(sort: Desc)])
  @@map("stock_movements")
}

// Table Support Tickets
model SupportTicket {
  id           String @id @default(uuid()) @db.Uuid
  restaurantId String @map("restaurant_id") @db.Uuid
  userId       String @map("user_id") @db.Uuid

  // Contenu
  subject     String
  description String
  status      TicketStatus   @default(open)
  priority    TicketPriority @default(medium)

  // Méta
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  resolvedAt DateTime? @map("resolved_at")

  // Relations
  restaurant Restaurant      @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  messages   TicketMessage[]

  @@index([restaurantId, status])
  @@index([status, priority])
  @@map("support_tickets")
}

// Messages du ticket
model TicketMessage {
  id       String  @id @default(uuid()) @db.Uuid
  ticketId String  @map("ticket_id") @db.Uuid
  userId   String  @map("user_id") @db.Uuid
  message  String
  isAdmin  Boolean @default(false) @map("is_admin")

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@map("ticket_messages")
}

// Table optionnelle pour cache des stats (performance)
model DailyStats {
  id            String   @id @default(uuid()) @db.Uuid
  date          DateTime @db.Date
  restaurantId  String?  @map("restaurant_id") @db.Uuid
  ordersCount   Int      @default(0) @map("orders_count")
  revenue       Int      @default(0)
  avgOrderValue Int      @default(0) @map("avg_order_value")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant? @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

  @@unique([date, restaurantId])
  @@index([date])
  @@index([restaurantId, date])
  @@map("daily_stats")
}

// Table Logs Système
model SystemLog {
  id        String   @id @default(uuid()) @db.Uuid
  level     LogLevel
  action    String // Ex: "restaurant_created", "order_failed"
  message   String
  userId    String?  @map("user_id") @db.Uuid
  metadata  Json? // Données additionnelles
  createdAt DateTime @default(now()) @map("created_at")

  @@index([level, createdAt(sort: Desc)])
  @@index([action])
  @@map("system_logs")
}

model Role {
  id           String   @id @default(uuid()) @db.Uuid
  restaurantId String   @map("restaurant_id") @db.Uuid
  name         String
  description  String?
  isSystem     Boolean  @default(false) @map("is_system") // true pour admin et kitchen
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant      Restaurant       @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  permissions     RolePermission[]
  restaurantUsers RestaurantUser[]
  invitations     Invitation[]

  @@unique([restaurantId, name])
  @@index([restaurantId, isActive])
  @@map("roles")
}

model Permission {
  id          String             @id @default(uuid()) @db.Uuid
  resource    PermissionResource
  action      PermissionAction
  name        String // Nom lisible: "Créer des produits"
  description String? // Description détaillée
  category    String // Pour regrouper dans l'UI: "Menu", "Commandes", etc.
  isSystem    Boolean            @default(true) @map("is_system")

  // Relations
  rolePermissions RolePermission[]

  @@unique([resource, action])
  @@index([category])
  @@map("permissions")
}

model RolePermission {
  id           String   @id @default(uuid()) @db.Uuid
  roleId       String   @map("role_id") @db.Uuid
  permissionId String   @map("permission_id") @db.Uuid
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@map("role_permissions")
}

model Invitation {
  id           String           @id @default(uuid()) @db.Uuid
  restaurantId String           @map("restaurant_id") @db.Uuid
  email        String // Email de la personne invitée
  roleId       String           @map("role_id") @db.Uuid // Référence au rôle personnalisé
  token        String           @unique // Token unique pour le lien d'invitation
  status       InvitationStatus @default(pending)
  invitedBy    String           @map("invited_by") @db.Uuid // ID de l'admin qui a invité
  expiresAt    DateTime         @map("expires_at") // Date d'expiration (7 jours)
  acceptedAt   DateTime?        @map("accepted_at") // Date d'acceptation
  createdAt    DateTime         @default(now()) @map("created_at")
  updatedAt    DateTime         @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@index([restaurantId, status])
  @@index([email])
  @@index([token])
  @@map("invitations")
}

model Subscription {
  id           String @id @default(uuid()) @db.Uuid
  restaurantId String @unique @map("restaurant_id") @db.Uuid

  // Plan de base sélectionné (starter, business, premium)
  plan SubscriptionPlan

  // Statut de l'abonnement
  status SubscriptionStatus @default(trial)

  // Dates importantes pour gérer les périodes d'essai et de facturation
  trialStartsAt      DateTime  @map("trial_starts_at")
  trialEndsAt        DateTime  @map("trial_ends_at")
  currentPeriodStart DateTime? @map("current_period_start")
  currentPeriodEnd   DateTime? @map("current_period_end")

  // NOUVEAU : Nombre d'utilisateurs actuellement actifs dans ce restaurant
  // Cette valeur est maintenue à jour automatiquement quand on ajoute/supprime des users
  activeUsersCount Int @default(1) @map("active_users_count")

  // Prix de base du plan choisi (sans les utilisateurs supplémentaires)
  basePlanPrice Int @map("base_plan_price")

  // Cycle de facturation en mois (1, 3, 6, ou 12)
  billingCycle Int @default(1) @map("billing_cycle")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  restaurant Restaurant             @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  payments   SubscriptionPayment[]
  emailLogs  SubscriptionEmailLog[]

  @@index([restaurantId, status])
  @@index([status, currentPeriodEnd])
  @@map("subscriptions")
}

model SubscriptionPayment {
  id             String @id @default(uuid()) @db.Uuid
  subscriptionId String @map("subscription_id") @db.Uuid
  restaurantId   String @map("restaurant_id") @db.Uuid

  amount       Int // Montant en FCFA
  method       SubscriptionPaymentMethod
  status       SubscriptionPaymentStatus @default(pending)
  billingCycle Int                       @map("billing_cycle") // Nombre de mois payés

  // Informations paiement manuel
  proofUrl    String?   @map("proof_url") // URL de la preuve de paiement (capture)
  manualNotes String?   @map("manual_notes") // Notes admin
  validatedBy String?   @map("validated_by") @db.Uuid // ID du super admin
  validatedAt DateTime? @map("validated_at")

  // Informations paiement mobile (V2)
  transactionId String? @map("transaction_id") // ID transaction Mobile Money
  phoneNumber   String? @map("phone_number")
  provider      String? // "airtel" ou "moov"

  errorMessage String? @map("error_message")

  userCount Int @default(1)

  // Dates
  paidAt    DateTime? @map("paid_at")
  expiresAt DateTime  @map("expires_at") // Date de fin de la période payée
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  restaurant   Restaurant   @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([restaurantId, status])
  @@index([status, createdAt])
  @@map("subscription_payments")
}

// Nouveau model pour tracer les emails envoyés
model SubscriptionEmailLog {
  id             String @id @default(uuid()) @db.Uuid
  subscriptionId String @map("subscription_id") @db.Uuid
  restaurantId   String @map("restaurant_id") @db.Uuid

  emailType      String @map("email_type") // "trial_7_days", "trial_3_days", "trial_1_day", etc.
  recipientEmail String @map("recipient_email")

  sentAt       DateTime @default(now()) @map("sent_at")
  status       String // "sent", "failed", "bounced"
  errorMessage String?  @map("error_message")

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  restaurant   Restaurant   @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

  @@index([subscriptionId, emailType])
  @@index([restaurantId, sentAt])
  @@map("subscription_email_logs")
}

// ============================================================
// NOUVEAU MODEL : Documents de vérification
// ============================================================

model RestaurantVerificationDocument {
  id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  restaurantId String     @unique @map("restaurant_id") @db.Uuid
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

  // Photo de profil (obligatoire)
  profilePhotoUrl        String?   @map("profile_photo_url")
  profilePhotoUploadedAt DateTime? @map("profile_photo_uploaded_at")

  // Pièce d'identité (obligatoire)
  identityDocumentUrl        String?   @map("identity_document_url")
  identityDocumentType       String?   @map("identity_document_type") // 'cni', 'passport', 'driving_license'
  identityDocumentUploadedAt DateTime? @map("identity_document_uploaded_at")

  // Statut de vérification
  verificationStatus RestaurantVerificationStatus @default(pending_documents) @map("verification_status")

  // Validation par superadmin
  verifiedBy String?   @map("verified_by") @db.Uuid
  verifiedAt DateTime? @map("verified_at")

  // Rejet
  rejectionReason String?   @map("rejection_reason")
  rejectedBy      String?   @map("rejected_by") @db.Uuid
  rejectedAt      DateTime? @map("rejected_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([restaurantId])
  @@index([verificationStatus])
  @@map("restaurant_verification_documents")
}

// ============================================================
// Fiche circuit ( à partir de Business...)
// ============================================================

model RestaurantCircuitSheet {
  id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  restaurantId String     @unique @map("restaurant_id") @db.Uuid
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

  // Document fiche circuit
  circuitSheetUrl        String?   @map("circuit_sheet_url")
  circuitSheetUploadedAt DateTime? @map("circuit_sheet_uploaded_at")

  // Échéance (3 mois après activation Business)
  deadlineAt DateTime @map("deadline_at")

  // Statut
  isSubmitted Boolean @default(false) @map("is_submitted")
  isValidated Boolean @default(false) @map("is_validated")

  // Validation par superadmin
  validatedBy String?   @map("validated_by") @db.Uuid
  validatedAt DateTime? @map("validated_at")

  // Suspension automatique
  autoSuspendedAt DateTime? @map("auto_suspended_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([restaurantId])
  @@index([deadlineAt])
  @@map("restaurant_circuit_sheets")
}

// ============================================================
// Historique des vérifications
// ============================================================

model RestaurantVerificationHistory {
  id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  restaurantId String     @map("restaurant_id") @db.Uuid
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

  // Type d'événement
  eventType String @map("event_type")

  // Détails
  oldStatus RestaurantVerificationStatus? @map("old_status")
  newStatus RestaurantVerificationStatus? @map("new_status")

  // Qui a effectué l'action
  performedBy String? @map("performed_by") @db.Uuid

  // Commentaire
  comment String?

  createdAt DateTime @default(now()) @map("created_at")

  @@index([restaurantId])
  @@index([eventType])
  @@index([createdAt(sort: Desc)])
  @@map("restaurant_verification_history")
}

// ============================================================
// Produit stocké dans le magasin/entrepôt
// ============================================================

model WarehouseProduct {
  id           String @id @default(uuid()) @db.Uuid
  restaurantId String @map("restaurant_id") @db.Uuid

  name        String  @db.VarChar(255)
  sku         String? @db.VarChar(100)
  description String? @db.Text

  storageUnit     String @map("storage_unit") @db.VarChar(50)
  unitsPerStorage Int    @default(1) @map("units_per_storage")

  imageUrl String? @map("image_url") @db.Text
  category String? @db.VarChar(100)

  linkedProductId String? @map("linked_product_id") @db.Uuid
  conversionRatio Decimal @default(1.00) @map("conversion_ratio") @db.Decimal(10, 2)

  notes    String? @db.Text
  isActive Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  restaurant    Restaurant               @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  linkedProduct Product?                 @relation("WarehouseToProduct", fields: [linkedProductId], references: [id], onDelete: SetNull)
  stock         WarehouseStock[]
  movements     WarehouseMovement[]
  transfers     WarehouseToOpsTransfer[]

  @@index([restaurantId])
  @@index([linkedProductId])
  @@map("warehouse_products")
}

// ============================================================
// Stock actuel dans le magasin
// ============================================================
model WarehouseStock {
  id                 String @id @default(uuid()) @db.Uuid
  restaurantId       String @map("restaurant_id") @db.Uuid
  warehouseProductId String @map("warehouse_product_id") @db.Uuid

  quantity       Decimal @default(0) @db.Decimal(10, 2)
  alertThreshold Decimal @default(10) @map("alert_threshold") @db.Decimal(10, 2)

  unitCost Decimal? @map("unit_cost") @db.Decimal(10, 2)
  // totalValue est calculé automatiquement par PostgreSQL

  lastInventoryDate DateTime? @map("last_inventory_date") @db.Timestamptz

  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  restaurant       Restaurant       @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  warehouseProduct WarehouseProduct @relation(fields: [warehouseProductId], references: [id], onDelete: Cascade)

  @@unique([restaurantId, warehouseProductId])
  @@index([restaurantId])
  @@index([warehouseProductId])
  @@map("warehouse_stock")
}

// ============================================================
// Mouvements de stock dans le magasin
// ============================================================

model WarehouseMovement {
  id                 String @id @default(uuid()) @db.Uuid
  restaurantId       String @map("restaurant_id") @db.Uuid
  warehouseProductId String @map("warehouse_product_id") @db.Uuid

  movementType String  @map("movement_type") @db.VarChar(50)
  quantity     Decimal @db.Decimal(10, 2)

  previousQty Decimal @map("previous_qty") @db.Decimal(10, 2)
  newQty      Decimal @map("new_qty") @db.Decimal(10, 2)

  supplierName     String? @map("supplier_name") @db.VarChar(255)
  invoiceReference String? @map("invoice_reference") @db.VarChar(100)
  destination      String? @db.VarChar(100)
  reason           String? @db.Text

  performedBy String? @map("performed_by") @db.Uuid
  notes       String? @db.Text

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  restaurant       Restaurant       @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  warehouseProduct WarehouseProduct @relation(fields: [warehouseProductId], references: [id], onDelete: Cascade)

  @@index([restaurantId])
  @@index([warehouseProductId])
  @@index([movementType])
  @@index([createdAt])
  @@map("warehouse_movements")
}

// ============================================================
// Transferts du magasin vers le stock opérationnel
// ============================================================
model WarehouseToOpsTransfer {
  id           String @id @default(uuid()) @db.Uuid
  restaurantId String @map("restaurant_id") @db.Uuid

  warehouseProductId String  @map("warehouse_product_id") @db.Uuid
  warehouseQuantity  Decimal @map("warehouse_quantity") @db.Decimal(10, 2)

  opsProductId String  @map("ops_product_id") @db.Uuid
  opsQuantity  Decimal @map("ops_quantity") @db.Decimal(10, 2)

  conversionRatio Decimal @map("conversion_ratio") @db.Decimal(10, 2)

  transferredBy String? @map("transferred_by") @db.Uuid
  notes         String? @db.Text

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  restaurant       Restaurant       @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  warehouseProduct WarehouseProduct @relation(fields: [warehouseProductId], references: [id], onDelete: Cascade)
  opsProduct       Product          @relation("TransferToProduct", fields: [opsProductId], references: [id], onDelete: Cascade)

  @@index([restaurantId])
  @@index([warehouseProductId])
  @@index([opsProductId])
  @@map("warehouse_to_ops_transfers")
}

model CashSession {
  id           String @id @default(uuid()) @db.Uuid
  restaurantId String @map("restaurant_id") @db.Uuid

  // La date de la session sans l'heure. Stocker uniquement la date
  // (type @db.Date) garantit l'unicité : une seule session par jour.
  // C'est aussi ce qui permet les saisies antidatées proprement.
  sessionDate DateTime @map("session_date") @db.Date

  status CashSessionStatus @default(open)

  // Montant physique dans le tiroir au moment de l'ouverture.
  // Pour une saisie historique, ce champ peut rester à 0.
  openingBalance Int @default(0) @map("opening_balance")

  // Ces trois champs ne sont remplis qu'à la clôture de la session.
  closingBalance     Int? @map("closing_balance")
  theoreticalBalance Int? @map("theoretical_balance")
  balanceDifference  Int? @map("balance_difference")

  notes    String?
  openedAt DateTime  @default(now()) @map("opened_at")
  closedAt DateTime? @map("closed_at")

  openedBy String  @map("opened_by") @db.Uuid
  closedBy String? @map("closed_by") @db.Uuid

  // Ce flag distingue les sessions créées en temps réel
  // des saisies antidatées depuis un cahier de recette.
  isHistorical Boolean @default(false) @map("is_historical")

  restaurant     Restaurant      @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  manualRevenues ManualRevenue[]
  expenses       Expense[]

  // Contrainte clé : impossible d'avoir deux sessions le même jour
  // pour le même restaurant. Prisma lèvera une erreur explicite si on essaie.
  @@unique([restaurantId, sessionDate])
  @@index([restaurantId, sessionDate(sort: Desc)])
  @@map("cash_sessions")
}

model ManualRevenue {
  id           String @id @default(uuid()) @db.Uuid
  restaurantId String @map("restaurant_id") @db.Uuid
  sessionId    String @map("session_id") @db.Uuid

  // Description libre : "Vente comptoir midi", "Buffet mariage", etc.
  description String

  // Lien optionnel à un produit du menu.
  // Devient obligatoire (côté logique applicative) si revenueType = 'good'.
  productId String? @map("product_id") @db.Uuid

  quantity    Int @default(1)
  unitAmount  Int @map("unit_amount")
  // totalAmount est toujours = quantity * unitAmount.
  // On le stocke pour éviter de recalculer à chaque agrégation SQL.
  totalAmount Int @map("total_amount")

  paymentMethod PaymentMethod @map("payment_method")
  revenueType   RevenueType   @default(service) @map("revenue_type")

  notes     String?
  createdAt DateTime @default(now()) @map("created_at")

  restaurant Restaurant  @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  session    CashSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  product    Product?    @relation(fields: [productId], references: [id], onDelete: SetNull)

  // Si la recette est de type 'good', ce champ référence le StockMovement
  // créé automatiquement. Cela permet de tracer l'origine de chaque mouvement.
  stockMovementId String?        @unique @map("stock_movement_id") @db.Uuid
  stockMovement   StockMovement? @relation("ManualRevenueStockMovement", fields: [stockMovementId], references: [id], onDelete: SetNull)

  @@index([restaurantId, sessionId])
  @@map("manual_revenues")
}

model Expense {
  id           String @id @default(uuid()) @db.Uuid
  restaurantId String @map("restaurant_id") @db.Uuid
  sessionId    String @map("session_id") @db.Uuid

  description   String
  amount        Int
  category      ExpenseCategory
  paymentMethod PaymentMethod   @map("payment_method")

  // Ces deux champs sont actifs uniquement si category = stock_purchase.
  // Le produit reçu et la quantité physique entrée en stock.
  productId     String? @map("product_id") @db.Uuid
  quantityAdded Int?    @map("quantity_added")

  notes     String?
  createdAt DateTime @default(now()) @map("created_at")

  restaurant Restaurant  @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  session    CashSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  product    Product?    @relation(fields: [productId], references: [id], onDelete: SetNull)

  stockMovementId String?        @unique @map("stock_movement_id") @db.Uuid
  stockMovement   StockMovement? @relation("ExpenseStockMovement", fields: [stockMovementId], references: [id], onDelete: SetNull)

  @@index([restaurantId, sessionId])
  @@index([restaurantId, category])
  @@map("expenses")
}
